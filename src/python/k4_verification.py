#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
K4 STRUCTURE VERIFICATION
=========================

Bool x Bool hat eine Symmetriegruppe. Welche?
"""

print("="*70)
print("K4 STRUCTURE - Bool x Bool Automorphisms")
print("="*70)

# The 4 elements of Bool x Bool
BxB = [(0,0), (0,1), (1,0), (1,1)]

print("\nBool x Bool = {(0,0), (0,1), (1,0), (1,1)}")
print()

# All bijections Bool x Bool -> Bool x Bool that preserve structure
# Structure = the product structure, i.e. projections

def is_product_automorphism(f):
    """
    A product automorphism must be of the form:
    (a,b) |-> (g(a), h(b))  or  (a,b) |-> (g(b), h(a))
    where g, h are automorphisms of Bool
    """
    # Check if it's a bijection
    image = [f(x) for x in BxB]
    if len(set(image)) != 4:
        return False
    # Check if it preserves product structure... 
    # Actually for Bool x Bool, we want Aut of the SET, not the product
    return True

# Possible automorphisms of Bool x Bool as a SET:
# There are 4! = 24 bijections total
# But we want those that respect the K4 structure

# The automorphisms are:
# 1. id: (a,b) -> (a,b)
# 2. swap: (a,b) -> (b,a)  
# 3. not_fst: (a,b) -> (1-a, b)
# 4. not_snd: (a,b) -> (a, 1-b)
# 5. not_both: (a,b) -> (1-a, 1-b)
# 6. swap_not_fst: (a,b) -> (b, 1-a)
# etc.

# But if we only consider PRODUCT automorphisms:
# These must have form f(a,b) = (g(a), h(b)) or f(a,b) = (g(b), h(a))
# where g, h in Aut(Bool) = {id, not}

print("PRODUCT AUTOMORPHISMS of Bool x Bool:")
print("-"*50)

def id_bool(x): return x
def not_bool(x): return 1-x

aut_bool = {'id': id_bool, 'not': not_bool}

product_auts = {}

# Form (g(a), h(b))
for gname, g in aut_bool.items():
    for hname, h in aut_bool.items():
        name = f"({gname},{hname})"
        f = lambda x, g=g, h=h: (g(x[0]), h(x[1]))
        product_auts[name] = f

# Form (g(b), h(a)) - with swap
for gname, g in aut_bool.items():
    for hname, h in aut_bool.items():
        name = f"swap.({gname},{hname})"
        f = lambda x, g=g, h=h: (g(x[1]), h(x[0]))
        product_auts[name] = f

print(f"Found {len(product_auts)} product automorphisms:\n")

for name, f in product_auts.items():
    result = [f(x) for x in BxB]
    print(f"  {name:20} : {BxB}")
    print(f"  {' '*20} -> {result}")
    print()

print("-"*50)
print("SYMMETRIEGRUPPE als abstrakte Gruppe:")
print("-"*50)

# Let's define the standard K4 generators
def e(x): return x
def a(x): return (x[1], x[0])  # swap
def b(x): return (1-x[0], x[1])  # not first
def c(x): return (x[0], 1-x[1])  # not second

k4 = {'e': e, 'a': a, 'b': b, 'c': c}

def compose(f, g):
    return lambda x: f(g(x))

def eq(f, g):
    return all(f(x) == g(x) for x in BxB)

def find_in_k4(f):
    for name, g in k4.items():
        if eq(f, g):
            return name
    # Check compositions
    for n1, f1 in k4.items():
        for n2, f2 in k4.items():
            if eq(f, compose(f1, f2)):
                return f"{n1}*{n2}"
    return "?"

print("\nK4 mit {e, a=swap, b=not_fst, c=not_snd}:")
print()
print("Multiplikationstafel:")
print("      | e     a     b     c")
print("  ----+------------------------")

for n1 in ['e', 'a', 'b', 'c']:
    row = f"  {n1}   |"
    for n2 in ['e', 'a', 'b', 'c']:
        f1, f2 = k4[n1], k4[n2]
        result = find_in_k4(compose(f1, f2))
        row += f" {result:5}"
    print(row)

print()
print("-"*50)
print("PROBLEM: Ist diese Gruppe abelsch?")
print("-"*50)

print("\nTest: a*b vs b*a")
ab = compose(k4['a'], k4['b'])
ba = compose(k4['b'], k4['a'])
print(f"  a*b: {[ab(x) for x in BxB]}")
print(f"  b*a: {[ba(x) for x in BxB]}")
print(f"  a*b = b*a? {eq(ab, ba)}")

print("\nWenn a*b != b*a, dann ist die Gruppe NICHT K4!")
print()

# Actually let's compute the full group
print("-"*50)
print("VOLLSTAENDIGE GRUPPENBERECHNUNG:")
print("-"*50)

# Generate all elements by closure
elements = {'e': e, 'a': a, 'b': b, 'c': c}
new_found = True
while new_found:
    new_found = False
    new_elements = {}
    for n1, f1 in list(elements.items()):
        for n2, f2 in list(elements.items()):
            comp = compose(f1, f2)
            # Check if this is new
            is_new = True
            for existing in elements.values():
                if eq(comp, existing):
                    is_new = False
                    break
            for existing in new_elements.values():
                if eq(comp, existing):
                    is_new = False
                    break
            if is_new:
                new_elements[f"({n1}*{n2})"] = comp
                new_found = True
    elements.update(new_elements)
    if len(elements) > 24:  # S4 has 24 elements max
        break

print(f"\nGruppe hat {len(elements)} Elemente")

# Actually K4 should be generated by just swap and one not
print("\n-"*50)
print("KORREKTUR: K4 = {e, a, b, ab} mit ab = a*b = b*a")
print("-"*50)

# K4 is generated by two commuting involutions
# Let's use: sigma = swap, tau = (not, not)

def sigma(x): return (x[1], x[0])  # swap
def tau(x): return (1-x[0], 1-x[1])  # both not

print("\nGeneratoren:")
print(f"  sigma (swap): {[sigma(x) for x in BxB]}")
print(f"  tau (not,not): {[tau(x) for x in BxB]}")

print("\nVerifikation:")
print(f"  sigma^2 = e? {eq(compose(sigma, sigma), e)}")
print(f"  tau^2 = e? {eq(compose(tau, tau), e)}")

sigma_tau = compose(sigma, tau)
tau_sigma = compose(tau, sigma)
print(f"  sigma*tau: {[sigma_tau(x) for x in BxB]}")
print(f"  tau*sigma: {[tau_sigma(x) for x in BxB]}")
print(f"  sigma*tau = tau*sigma? {eq(sigma_tau, tau_sigma)}")

print("\nDamit: K4 = {e, sigma, tau, sigma*tau}")
print("       Dies ist Z2 x Z2, die Klein-Vierergruppe.")

print("\n" + "="*70)
print("FAZIT:")
print("="*70)
print("""
Die SYMMETRIEGRUPPE von Bool x Bool (als Produkt) ist:

  Sym(Bool x Bool) = Aut(Bool) wr Z2
                   = (Z2 x Z2) semi Z2
                   
  wobei Z2 durch swap wirkt.
  
  Diese hat 8 Elemente, NICHT 4!
  
  {(id,id), (id,not), (not,id), (not,not)} x {e, swap}
  
ABER: Die Untergruppe die durch {swap, (not,not)} erzeugt wird
      IST K4 = Z2 x Z2.
      
Fuer die COHERENCE LAWS ist relevant:
- swap erzeugt Braiding-Gesetze
- (not,not) ist die "Dualitaet" phi <-> not-phi
""")
